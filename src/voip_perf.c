/*
 * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)
 * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>
 * Copyright (C) 2017-2018 Julien Chavanton <jchavanton@gmail.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA 
 */

/**
 * SIP Performance Benchmark
 *
 * <b>voip_perf</b> is a complete program to measure the
 * performance of PJSIP or other SIP endpoints. It consists of two
 * parts:
 *  - the server, to respond incoming requests, and
 *  - the client, who actively submits requests and measure the
 *     performance of the server.
 *
 * Both server and client part can run simultaneously, to measure the
 * performance when both endpoints are co-located in a single program.
 * 
 * The server accepts both INVITE and non-INVITE requests.
 * The server exports several different types of URL, which would
 * control how the request would be handled by the server:
 *  - URL with "0" as the user part will be handled statelessly.
 *    It should not be used with INVITE method.
 *  - URL with "1" as the user part will be handled statefully.
 *    If the request is an INVITE request, INVITE transaction will
 *    be created and 200/OK response will be sent, along with a valid
 *    SDP body. However, the SDP is just a static text body, and
 *    is not a proper SDP generated by PJMEDIA.
 *  - URL with "2" as the user part is only meaningful for INVITE
 *    requests, as it would be handled <b>call-statefully</b> by the
 *    server. For this URL, the server also would generate SDP dynamically
 *    and perform a proper SDP negotiation for the incoming call.
 *    Also for every call, server will limit the call duration to
 *    10 seconds, on which the call will be terminated if the client
 *    doesn't hangup the call.
 *
 */

#define PJSIP_MAX_TSX_COUNT (131072-1)

// PJSIP_MAX_TSX_COUNT
/* Include all headers. */
#include <pjsip.h>
#include <pjmedia.h>
#include <pjmedia-codec.h>
#include <pjsip_ua.h>
#include <pjsip_simple.h>
#include <pjlib-util.h>
#include <pjlib.h>
#include <stdio.h>
#include <jansson.h>

#include "custom_headers.h"
#include "voip_perf.h"
#include "version.h"
#include <signal.h>

// random
#include <time.h>

// INET ADDR
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#if (defined(PJ_WIN32) && PJ_WIN32!=0) || (defined(PJ_WIN64) && PJ_WIN64!=0)
#  include <windows.h>
#endif

#define THIS_FILE	    "voip_perf.c"
#define DEFAULT_COUNT	    (pjsip_cfg()->tsx.max_count/2>10000?10000:pjsip_cfg()->tsx.max_count/2)
#define JOB_WINDOW	    1000
#define TERMINATE_TSX(x,c)


#ifndef CACHING_POOL_SIZE
#   define CACHING_POOL_SIZE   (256*1024*1024)
#endif


#define CONFIG_DEFAULT_FN "./conf.json"

/* Static message body for INVITE, when stateful processing is
 * invoked (instead of call-stateful, where SDP is generated
 * dynamically.
 */
static pj_str_t dummy_sdp_str = {
    "v=0\r\n"
    "o=- 3360842071 3360842071 IN IP4 192.168.0.68\r\n"
    "s=pjmedia\r\n"
    "c=IN IP4 192.168.0.68\r\n"
    "t=0 0\r\n"
    "m=audio 4000 RTP/AVP 0 8 3 103 102 101\r\n"
    "a=rtcp:4001 IN IP4 192.168.0.68\r\n"
    "a=rtpmap:103 speex/16000\r\n"
    "a=rtpmap:102 speex/8000\r\n"
    "a=rtpmap:3 GSM/8000\r\n"
    "a=rtpmap:0 PCMU/8000\r\n"
    "a=rtpmap:8 PCMA/8000\r\n"
    "a=sendrecv\r\n"
    "a=rtpmap:101 telephone-event/8000\r\n"
    "a=fmtp:101 0-15\r\n",
    0
};

static pj_str_t mime_application = { "application", 11};
static pj_str_t mime_sdp = {"sdp", 3};


struct app {
	pj_caching_pool cp;
	pj_pool_t *pool;
	pj_bool_t use_tcp;
	pj_bool_t use_tls;
	pj_str_t local_addr;
	int local_port;
	pjsip_endpoint *sip_endpt;
	pjmedia_endpt *med_endpt;
	pj_str_t local_uri;
	pj_str_t local_contact;
	pj_str_t local_contact_nat; // When behind NAT this will be the public contact URI
	pj_str_t nat_ip;            // When behind NAT this will be the public IP
	unsigned skinfo_cnt;
	pjmedia_sock_info skinfo[8];
	pj_bool_t thread_quit;
	pj_bool_t client_mode;
	unsigned thread_count;
	pj_thread_t *thread[16];
	pj_bool_t real_sdp;
	pjmedia_sdp_session *dummy_sdp;
	int log_level;
	pjsip_route_hdr route_set;
	pj_str_t cfg_fn;
	pj_bool_t disable_connection_reuse;
	struct {
		pjsip_method method;
		pj_str_t dst_uri;
		pj_str_t callerid;
		pj_bool_t stateless;
		unsigned timeout, interval;
		unsigned job_count, job_submitted, job_connected, job_finished, job_window;
		unsigned stat_max_window;
		unsigned call_duration;
		unsigned cps;
		pj_time_val first_request;
		pj_time_val requests_sent;
		pj_time_val last_completion;
		pj_time_val last_connection;
		unsigned total_responses;
		unsigned connection_total_responses;
		unsigned response_codes[800];
		unsigned connection_response_codes[800];
		int custom_headers_count;
		int users_count;
		int current_user;
		extra_header_t *extra_headers;
		user_t *users;
	} client;

	struct {
		pj_bool_t console_mode;
		pj_bool_t send_trying;
		pj_bool_t send_ringing;
		unsigned delay;
		unsigned call_duration;
		struct srv_state prev_state;
		struct srv_state cur_state;
		responses_t *responses;
		int responses_count;
	} server;

	pj_str_t latency_fn;
	struct {
		pj_str_t cert;
		pj_str_t key;
		pj_str_t pass;
		pj_str_t calist;
	} tls;

	voip_perf_metric_t latency_metrics[3];
	// latency_metrics[3];
	pj_time_val latency_metrics_period_start;
	pj_time_val status_metrics_period_start;
	int latency_metrics_period_duration;
	int status_metrics_period_duration;

	pj_lock_t *stats_lock;
	pj_lock_t *cps_lock;
	cps_period_t cps_period;
} app;

static FILE *log_stats_output = NULL;

struct call {
	pjsip_inv_session *inv;
	pj_timer_entry ans_timer;
	pj_timer_entry cancel_timer;
	pj_timer_entry hangup_timer;
};

typedef struct outbound_call {
	pjsip_inv_session *inv;
	pj_timer_entry hangup_timer;
} outbound_call_t;

static void app_perror(const char *sender, const char *title, pj_status_t status) {
	char errmsg[PJ_ERR_MSG_SIZE];
	pj_strerror(status, errmsg, sizeof(errmsg));
	PJ_LOG(1,(sender, "%s: %s [code=%d]", title, errmsg, status));
}

/* Used to keep track of disconnection BYE timers */
static pjsip_module mod_callcontrol =
{
    NULL, NULL,			    /* prev, next.		*/
    { "mod-callcontrol", 9 },	    /* Name.			*/
    -1,				    /* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION, /* Priority			*/
    NULL,			    /* load()			*/
    NULL,			    /* start()			*/
    NULL,			    /* stop()			*/
    NULL,			    /* unload()			*/
    NULL,			    /* on_rx_request()		*/
    NULL,			    /* on_rx_response()		*/
    NULL,			    /* on_tx_request.		*/
    NULL,			    /* on_tx_response()		*/
    NULL,			    /* on_tsx_state()		*/
};

/**************************************************************************
 * STATELESS SERVER
 */
static pj_bool_t mod_stateless_on_rx_request(pjsip_rx_data *rdata);

/* Module to handle incoming requests statelessly.
 */
static pjsip_module mod_stateless_server =
{
    NULL, NULL,			    /* prev, next.		*/
    { "mod-stateless-server", 20 }, /* Name.			*/
    -1,				    /* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION, /* Priority			*/
    NULL,			    /* load()			*/
    NULL,			    /* start()			*/
    NULL,			    /* stop()			*/
    NULL,			    /* unload()			*/
    &mod_stateless_on_rx_request,   /* on_rx_request()		*/
    NULL,			    /* on_rx_response()		*/
    NULL,			    /* on_tx_request.		*/
    NULL,			    /* on_tx_response()		*/
    NULL,			    /* on_tsx_state()		*/
};

static pj_bool_t mod_stateless_on_rx_request(pjsip_rx_data *rdata) {
	const pj_str_t stateless_user = { "0", 1 };
	const pj_str_t no_user = { "", 0 };
	pjsip_uri *uri;
	pjsip_sip_uri *sip_uri;

	uri = pjsip_uri_get_uri(rdata->msg_info.msg->line.req.uri);

	/* Only want to receive SIP/SIPS scheme */
	if (!PJSIP_URI_SCHEME_IS_SIP(uri) && !PJSIP_URI_SCHEME_IS_SIPS(uri))
	return PJ_FALSE;

	sip_uri = (pjsip_sip_uri*) uri;

	if (rdata->msg_info.msg->line.req.method.id == PJSIP_REGISTER_METHOD) {
		/* should add the header expire and contact */
	} else if (rdata->msg_info.msg->line.req.method.id == PJSIP_OPTIONS_METHOD) {
		/* reply statelessly to OPTIONS */
	} else if (pj_strcmp(&sip_uri->user, &stateless_user)!=0 ) {
		return PJ_FALSE;
	}

	// Yes, this is for us.

	/* Ignore ACK request */
	if (rdata->msg_info.msg->line.req.method.id == PJSIP_ACK_METHOD)
		return PJ_TRUE;

	/* Respond statelessly with 200/OK */
	pjsip_endpt_respond_stateless(app.sip_endpt, rdata, 200, NULL, NULL, NULL);
	app.server.cur_state.stateless_cnt++;
	return PJ_TRUE;
}

/**************************************************************************
 * STATEFUL SERVER
 */
static pj_bool_t mod_stateful_on_rx_request(pjsip_rx_data *rdata);
static pj_bool_t mod_stateful_on_rx_response(pjsip_rx_data *rdata);

/* Module to handle incoming requests statefully.
 */
static pjsip_module mod_stateful_server =
{
    NULL, NULL,			    /* prev, next.		*/
    { "mod-stateful-server", 19 },  /* Name.			*/
    -1,				    /* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION, /* Priority			*/
    NULL,			    /* load()			*/
    NULL,			    /* start()			*/
    NULL,			    /* stop()			*/
    NULL,			    /* unload()			*/
    &mod_stateful_on_rx_request,    /* on_rx_request()		*/
    NULL,			    /* on_rx_response()		*/
    NULL,			    /* on_tx_request.		*/
    NULL,			    /* on_tx_response()		*/
    NULL,			    /* on_tsx_state()		*/
};


static pj_bool_t mod_stateful_on_rx_request(pjsip_rx_data *rdata) {
	const pj_str_t stateful_user = { "1", 1 };
	pjsip_uri *uri;
	pjsip_sip_uri *sip_uri;
	uri = pjsip_uri_get_uri(rdata->msg_info.msg->line.req.uri);

	/* Only want to receive SIP/SIPS scheme */
	if (!PJSIP_URI_SCHEME_IS_SIP(uri) && !PJSIP_URI_SCHEME_IS_SIPS(uri))
		return PJ_FALSE;

	sip_uri = (pjsip_sip_uri*) uri;

	/* Check for matching user part */
	if (pj_strcmp(&sip_uri->user, &stateful_user)!=0)
		return PJ_FALSE;

	/* Yes, this is for us. Respond statefully with 200/OK. */
	switch (rdata->msg_info.msg->line.req.method.id) {
	case PJSIP_INVITE_METHOD: {
		pjsip_msg_body *body;
		if (dummy_sdp_str.slen == 0)
			dummy_sdp_str.slen = pj_ansi_strlen(dummy_sdp_str.ptr);

		body = pjsip_msg_body_create(rdata->tp_info.pool, &mime_application, &mime_sdp, &dummy_sdp_str);
		pjsip_endpt_respond(app.sip_endpt, &mod_stateful_server, rdata, 200, NULL, NULL, body, NULL);
		}
		break;
	case PJSIP_ACK_METHOD:
		return PJ_TRUE;
	default:
		pjsip_endpt_respond(app.sip_endpt, &mod_stateful_server, rdata, 200, NULL, NULL, NULL, NULL);
		break;
	}

	app.server.cur_state.stateful_cnt++;
	return PJ_TRUE;
}


/**************************************************************************
 * CALL SERVER
 */
static pj_bool_t mod_call_on_rx_request(pjsip_rx_data *rdata);

/* Module to handle incoming requests callly.
 */
static pjsip_module mod_call_server = {
    NULL, NULL,			    /* prev, next.		*/
    { "mod-call-server", 15 },	    /* Name.			*/
    -1,				    /* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION, /* Priority			*/
    NULL,			    /* load()			*/
    NULL,			    /* start()			*/
    NULL,			    /* stop()			*/
    NULL,			    /* unload()			*/
    &mod_call_on_rx_request,	    /* on_rx_request()		*/
    NULL,			    /* on_rx_response()		*/
    NULL,			    /* on_tx_request.		*/
    NULL,			    /* on_tx_response()		*/
    NULL,			    /* on_tsx_state()		*/
};

static pj_status_t send_response(pjsip_inv_session *inv, pjsip_rx_data *rdata, int code, pj_str_t *reason, pj_bool_t *has_initial) {
	pjsip_tx_data *tdata;
	pj_status_t status;

	if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
		return PJ_FALSE;
	}
	if (*has_initial) {
		if (!inv->invite_tsx)
			return PJ_FALSE;
		status = pjsip_inv_answer(inv, code, NULL, NULL, &tdata);
	} else {
		status = pjsip_inv_initial_answer(inv, rdata, code, NULL, NULL, &tdata);
	}

	if (status != PJ_SUCCESS) {
		if (*has_initial) {
			status = pjsip_inv_answer(inv, PJSIP_SC_NOT_ACCEPTABLE, NULL, NULL, &tdata);
		} else {
			status = pjsip_inv_initial_answer(inv, rdata, PJSIP_SC_NOT_ACCEPTABLE, NULL, NULL, &tdata);
		}
		if (status == PJ_SUCCESS) {
			*has_initial = PJ_TRUE;
			pjsip_inv_send_msg(inv, tdata);
		} else {
			pjsip_inv_terminate(inv, 500, PJ_FALSE);
			return -1;
		}
	} else {
		*has_initial = PJ_TRUE;
		status = pjsip_inv_send_msg(inv, tdata); 
		if (status != PJ_SUCCESS) {
			pjsip_tx_data_dec_ref(tdata);
			return status;
		}
	}
	return status;
}

static void cancel_timer_cb(pj_timer_heap_t *h, pj_timer_entry *entry) {
	struct call *call = entry->user_data;
	pj_bool_t has_initial = PJ_TRUE;
	PJ_UNUSED_ARG(h);
	entry->id = 0;
	send_response(call->inv, NULL, 487, NULL, &has_initial);
}

static void answer_timer_cb(pj_timer_heap_t *h, pj_timer_entry *entry) {
	struct call *call = entry->user_data;
	pj_bool_t has_initial = PJ_TRUE;
	PJ_UNUSED_ARG(h);
	entry->id = 0;
	send_response(call->inv, NULL, 200, NULL, &has_initial);
}

static void hangup_timer_cb(pj_timer_heap_t *h, pj_timer_entry *entry) {
	struct call *call = entry->user_data;
	PJ_UNUSED_ARG(h);
	pjsip_tx_data *tdata;
	pj_status_t status;
	PJ_LOG(4, (THIS_FILE, "hangup_timer "));
	if (call->inv->state == PJSIP_INV_STATE_CONFIRMED) {
		status = pjsip_inv_end_session(call->inv, PJSIP_SC_OK, NULL, &tdata);
		if (status == PJ_SUCCESS && tdata)
			status = pjsip_inv_send_msg(call->inv, tdata);
	} else {
		if (call->inv->state != PJSIP_INV_STATE_DISCONNECTED) {
			PJ_LOG(1, (THIS_FILE, "can not hangup call in this state : %d", call->inv->state));
		}
	}
	call->inv->mod_data[mod_callcontrol.id] = NULL;
}

static pj_bool_t mod_call_on_rx_request(pjsip_rx_data *rdata) {
	const pj_str_t call_user = { "2", 1 };
	pjsip_uri *uri;
	pjsip_sip_uri *sip_uri;
	struct call *call;
	pjsip_dialog *dlg;
	pjmedia_sdp_session *sdp;
	pjsip_tx_data *tdata;
	pj_bool_t has_initial = PJ_FALSE;
	pj_status_t status;

	uri = pjsip_uri_get_uri(rdata->msg_info.msg->line.req.uri);

	/* Only want to receive SIP/SIPS scheme */
	if (!PJSIP_URI_SCHEME_IS_SIP(uri) && !PJSIP_URI_SCHEME_IS_SIPS(uri))
		return PJ_FALSE;

	sip_uri = (pjsip_sip_uri*) uri;

	/* Only want to handle INVITE requests. */
	if (rdata->msg_info.msg->line.req.method.id != PJSIP_INVITE_METHOD) {
		return PJ_FALSE;
	}

	// Check for matching user part. Incoming requests will be handled 
	// call-statefully if:
	// - user part is "2", or
	// - user part is not "0" nor "1" and method is INVITE.
	if (pj_strcmp(&sip_uri->user, &call_user) == 0 || sip_uri->user.slen != 1 ||
		(*sip_uri->user.ptr != '0' && *sip_uri->user.ptr != '1')) {
	} else {
		return PJ_FALSE;
	}

	// Verify that we can handle the request.
	if (app.real_sdp) {
		unsigned options = 0;
		status = pjsip_inv_verify_request(rdata, &options, NULL, NULL, app.sip_endpt, &tdata);
		if (status != PJ_SUCCESS) {
		// No we can't handle the incoming INVITE request.
			if (tdata) {
				pjsip_response_addr res_addr;
				pjsip_get_response_addr(tdata->pool, rdata, &res_addr);
				pjsip_endpt_send_response(app.sip_endpt, &res_addr, tdata, NULL, NULL);
			} else {
				// Respond with 500 (Internal Server Error)
				pjsip_endpt_respond_stateless(app.sip_endpt, rdata, 500, NULL, NULL, NULL);
			}
		return PJ_TRUE;
		}
	}

	/* Create UAS dialog */
	if (app.local_contact_nat.slen) {
		status = pjsip_dlg_create_uas_and_inc_lock( pjsip_ua_instance(), rdata, &app.local_contact_nat, &dlg);
	} else {
		status = pjsip_dlg_create_uas_and_inc_lock( pjsip_ua_instance(), rdata, &app.local_contact, &dlg);
	}
	if (status != PJ_SUCCESS) {
		const pj_str_t reason = pj_str("Unable to create dialog");
		pjsip_endpt_respond_stateless( app.sip_endpt, rdata,500, &reason, NULL, NULL);
		return PJ_TRUE;
	}

	/* Alloc call structure. */
	call = pj_pool_zalloc(dlg->pool, sizeof(struct call));

	/* Create SDP from PJMEDIA */
	if (app.real_sdp) {
		status = pjmedia_endpt_create_sdp(app.med_endpt, rdata->tp_info.pool, app.skinfo_cnt, app.skinfo, &sdp);
	} else {
		sdp = app.dummy_sdp;
	}

	/* Create UAS invite session */
	status = pjsip_inv_create_uas( dlg, rdata, sdp, 0, &call->inv);
	if (status != PJ_SUCCESS) {
		pjsip_dlg_create_response(dlg, rdata, 500, NULL, &tdata);
		pjsip_dlg_send_response(dlg, pjsip_rdata_get_tsx(rdata), tdata);
		pjsip_dlg_dec_lock(dlg);
		return PJ_TRUE;
	}

	/* Invite session has been created, decrement & release dialog lock. */
	pjsip_dlg_dec_lock(dlg);

	app.server.cur_state.call_cnt++;

	const pj_str_t user_503 = { "503", 3 };
	if (pj_strcmp(&sip_uri->user, &user_503) == 0) {
		status = send_response(call->inv, rdata, 503, NULL, &has_initial);
			return PJ_TRUE;
	}
	/* json config responses */
	int i;
	int x = rand()%100;
	int y = 0;
	for (i=0;i< app.server.responses_count ;i++) {
		printf("[%d %.*s] [%d/100]\n", app.server.responses[i].code, (int)app.server.responses[i].reason.slen, app.server.responses[i].reason.ptr, app.server.responses[i].prob);
		if (x < (app.server.responses[i].prob+y)) {
			if (app.server.responses[i].code == 0) { // 0 == drop
				return PJ_TRUE;
			}
			if (app.server.responses[i].code == 487) {
				/* Send 100/Trying if needed */
				if (app.server.send_trying) {
					status = send_response(call->inv, rdata, 100, NULL, &has_initial);
					if (status != PJ_SUCCESS)
					return PJ_TRUE;
				}
				/* Send 180/Ringing if needed */
				if (app.server.send_ringing) {
					status = send_response(call->inv, rdata, 183, NULL, &has_initial);
					if (status != PJ_SUCCESS)
						return PJ_TRUE;
				}
				pj_time_val delay;
				call->cancel_timer.id = 1;
				call->cancel_timer.user_data = call;
				call->cancel_timer.cb = &cancel_timer_cb;
				delay.sec = 0;
				delay.msec = app.server.delay;
				pj_time_val_normalize(&delay);
				pjsip_endpt_schedule_timer(app.sip_endpt, &call->cancel_timer, &delay);
			} else {
				if (app.server.responses[i].code == 200) break;
				status = send_response(call->inv, rdata, app.server.responses[i].code,&app.server.responses[i].reason, &has_initial);
				if (status != PJ_SUCCESS) return PJ_TRUE;
			}
			return PJ_TRUE;
		}
		y += app.server.responses[i].prob;
	}

	/* Send 100/Trying if needed */
	if (app.server.send_trying) {
		status = send_response(call->inv, rdata, 100, NULL, &has_initial);
		if (status != PJ_SUCCESS)
		return PJ_TRUE;
	}
	/* Send 180/Ringing if needed */
	if (app.server.send_ringing) {
		status = send_response(call->inv, rdata, 183, NULL, &has_initial);
		if (status != PJ_SUCCESS)
			return PJ_TRUE;
	}

	/* Set max call duration */
	if (app.server.call_duration) {
		pj_time_val delay;
		call->hangup_timer.id = 1;
		call->hangup_timer.user_data = call;
		call->hangup_timer.cb = &hangup_timer_cb;
		delay.sec = app.server.call_duration;
		delay.msec = 0;
		pj_time_val_normalize(&delay);
		PJ_LOG(4, (THIS_FILE, "set max duration for this call duration[%d] ", delay.sec));
		pjsip_endpt_schedule_timer(app.sip_endpt, &call->hangup_timer, &delay);
		call->inv->mod_data[mod_callcontrol.id] = &call->hangup_timer;
	}

	/* Simulate call processing delay */
	if (app.server.delay) {
		pj_time_val delay;
		call->ans_timer.id = 1;
		call->ans_timer.user_data = call;
		call->ans_timer.cb = &answer_timer_cb;
		delay.sec = 0;
		delay.msec = app.server.delay;
		pj_time_val_normalize(&delay);
		pjsip_endpt_schedule_timer(app.sip_endpt, &call->ans_timer, &delay);
	} else {
		// Send the 200 response immediately
		status = send_response(call->inv, rdata, 200, NULL, &has_initial);
		PJ_ASSERT_ON_FAIL(status == PJ_SUCCESS, return PJ_TRUE);
	}


	return PJ_TRUE;
}

/**************************************************************************
 * Default handler when incoming request is not handled by any other
 * modules.
 */
static pj_bool_t mod_responder_on_rx_request(pjsip_rx_data *rdata);

/* Module to handle incoming requests statelessly.
 */
static pjsip_module mod_responder =
{
    NULL, NULL,			    /* prev, next.		*/
    { "mod-responder", 13 },	    /* Name.			*/
    -1,				    /* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION+1, /* Priority		*/
    NULL,			    /* load()			*/
    NULL,			    /* start()			*/
    NULL,			    /* stop()			*/
    NULL,			    /* unload()			*/
    &mod_responder_on_rx_request,   /* on_rx_request()		*/
    NULL,			    /* on_rx_response()		*/
    NULL,			    /* on_tx_request.		*/
    NULL,			    /* on_tx_response()		*/
    NULL,			    /* on_tsx_state()		*/
};

static pj_bool_t mod_responder_on_rx_request(pjsip_rx_data *rdata) {
	const pj_str_t reason = pj_str("Not expecting request at this URI");
	// Respond any requests (except ACK!) with 500
	if (rdata->msg_info.msg->line.req.method.id != PJSIP_ACK_METHOD) {
		pjsip_endpt_respond_stateless(app.sip_endpt, rdata, 200, &reason, NULL, NULL);
	}
	return PJ_TRUE;
}

/*****************************************************************************
 * Below is a simple module to log all incoming and outgoing SIP messages
 */

/* Notification on incoming messages */
static pj_bool_t logger_on_rx_msg(pjsip_rx_data *rdata) {
    PJ_LOG(3,(THIS_FILE, "RX %d bytes %s from %s %s:%d:\n"
			 "%.*s\n"
			 "--end msg--",
			 rdata->msg_info.len,
			 pjsip_rx_data_get_info(rdata),
			 rdata->tp_info.transport->type_name,
			 rdata->pkt_info.src_name,
			 rdata->pkt_info.src_port,
			 (int)rdata->msg_info.len,
			 rdata->msg_info.msg_buf));
    
    /* Always return false, otherwise messages will not get processed! */
    return PJ_FALSE;
}




/* Notification on outgoing messages */
static pj_status_t logger_on_tx_msg(pjsip_tx_data *tdata)
{
    
    /* Important note:
     *	tp_info field is only valid after outgoing messages has passed
     *	transport layer. So don't try to access tp_info when the module
     *	has lower priority than transport layer.
     */
    // 22:47:40.925   voip_perf.c  ...TX 824 bytes Request msg INVITE/cseq=124 (tdta0x7f25e40033b0) to UDP 147.75.69.1:5070:
    PJ_LOG(3,(THIS_FILE, "TX %d bytes %s to %s %s:%d:\n"
			 "%.*s\n"
			 "--end msg--",
			 (tdata->buf.cur - tdata->buf.start),
			 pjsip_tx_data_get_info(tdata),
			 tdata->tp_info.transport->type_name,
			 tdata->tp_info.dst_name,
			 tdata->tp_info.dst_port,
			 (int)(tdata->buf.cur - tdata->buf.start),
			 tdata->buf.start));

    /* Always return success, otherwise message will not get sent! */
    return PJ_SUCCESS;
}

/* The module instance. */
static pjsip_module msg_logger = 
{
    NULL, NULL,				/* prev, next.		*/
    { "mod-siprtp-log", 14 },		/* Name.		*/
    -1,					/* Id			*/
    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER-1,/* Priority	        */
    NULL,				/* load()		*/
    NULL,				/* start()		*/
    NULL,				/* stop()		*/
    NULL,				/* unload()		*/
    &logger_on_rx_msg,			/* on_rx_request()	*/
    &logger_on_rx_msg,			/* on_rx_response()	*/
    &logger_on_tx_msg,			/* on_tx_request.	*/
    &logger_on_tx_msg,			/* on_tx_response()	*/
    NULL,				/* on_tsx_state()	*/

};

static pj_status_t latency_on_tx_request(pjsip_tx_data *tdata) {
	if (tdata->msg->type == PJSIP_RESPONSE_MSG) {
		PJ_LOG(4, (THIS_FILE, "latency_on_tx_request"));
	} else {
		PJ_LOG(4, (THIS_FILE, "latency_on_tx_request [%s]", tdata->msg->line.req.method.name.ptr));
	}
	return PJ_SUCCESS;
}
static pj_bool_t latency_on_rx_response(pjsip_rx_data *rdata) {
	return PJ_FALSE;
}
void latency_on_tsx_state(pjsip_transaction *tsx, pjsip_event *event) {
	return;
}

/* The module instance. */
static pjsip_module mod_latency = 
{
    NULL, NULL,				/* prev, next.		*/
    { "mod-latency-mon", 15 },		/* Name.		*/
    -1,					/* Id			*/
    PJSIP_MOD_PRIORITY_TRANSPORT_LAYER-1,/* Priority	        */
    NULL,				/* load()		*/
    NULL,				/* start()		*/
    NULL,				/* stop()		*/
    NULL,				/* unload()		*/
    NULL,				/* on_rx_request()	*/
    &latency_on_rx_response,		/* on_rx_response()	*/
    &latency_on_tx_request,		/* on_tx_request.	*/
    NULL,				/* on_tx_response()	*/
    &latency_on_tsx_state,		/* on_tsx_state()	*/
};

/**************************************************************************
 * Test Client.
 */

static pj_bool_t mod_test_on_rx_response(pjsip_rx_data *rdata);

static void call_on_media_update( pjsip_inv_session *inv, pj_status_t status);
static void call_on_state_changed( pjsip_inv_session *inv, pjsip_event *e);
static void call_on_forked(pjsip_inv_session *inv, pjsip_event *e);
static void call_on_tsx_state_changed(pjsip_inv_session *inv, pjsip_transaction *tsx, pjsip_event *e);


/* Module to handle incoming requests callly.
 */
static pjsip_module mod_test =
{
    NULL, NULL,			    /* prev, next.		*/
    { "mod-test", 8 },		    /* Name.			*/
    -1,				    /* Id			*/
    PJSIP_MOD_PRIORITY_APPLICATION, /* Priority			*/
    NULL,			    /* load()			*/
    NULL,			    /* start()			*/
    NULL,			    /* stop()			*/
    NULL,			    /* unload()			*/
    NULL,			    /* on_rx_request()		*/
    &mod_test_on_rx_response,	    /* on_rx_response()		*/
    NULL,			    /* on_tx_request.		*/
    NULL,			    /* on_tx_response()		*/
    NULL,			    /* on_tsx_state()		*/
};


static void report_completion(int status_code, pj_str_t *method, pj_str_t* call_id)
{
	const pj_str_t str_invite = { "INVITE", 6 };
	const pj_str_t str_bye = { "BYE", 3 };
	if (pj_strcmp(method, &str_invite) == 0 ) {
		if (status_code >= 200 && status_code < 300)
			app.client.job_connected++;
		else if (status_code >= 300)
			app.client.job_finished++;
		if (status_code >= 200 && status_code < 800)
			app.client.connection_response_codes[status_code]++;
		app.client.connection_total_responses++;
		pj_gettimeofday(&app.client.last_connection);
	} else if (pj_strcmp(method, &str_bye) == 0) {
		app.client.job_finished++;
		if (status_code >= 200 && status_code < 800)
			app.client.response_codes[status_code]++;
		app.client.total_responses++;
		pj_gettimeofday(&app.client.last_completion);
	}
	if (method && status_code != 200) {
		if (call_id) {
			PJ_LOG(4,(THIS_FILE, "%s[%.*s][%.*s][%d]completed[%d]", __FUNCTION__, method->slen, method->ptr, call_id->slen, call_id->ptr, status_code, app.client.job_finished));
		} else {
			PJ_LOG(4,(THIS_FILE, "%s[%.*s][UNKNOWN]completed[%d]", __FUNCTION__, method->slen, method->ptr, status_code, app.client.job_finished));
		}
	}
}


/* Handler when response is received. */
static pj_bool_t mod_test_on_rx_response(pjsip_rx_data *rdata) {
	if (pjsip_rdata_get_tsx(rdata) == NULL) {
		report_completion(rdata->msg_info.msg->line.status.code, &rdata->msg_info.msg->line.req.method.name, NULL);
	}
	return PJ_TRUE;
}

/* Create app */
static pj_status_t create_app(void) {
	pj_status_t status;

	status = pj_init();
	if (status != PJ_SUCCESS) {
		app_perror(THIS_FILE, "Error initializing pjlib", status);
		return status;
	}

	/* init settings */
	app.client_mode = PJ_FALSE;

	/* init PJLIB-UTIL: */
	status = pjlib_util_init();
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Must create a pool factory before we can allocate any memory. */
	pj_caching_pool_init(&app.cp, &pj_pool_factory_default_policy, CACHING_POOL_SIZE);

	/* Create application pool for misc. */
	app.pool = pj_pool_create(&app.cp.factory, "app", 1000, 1000, NULL);

	/* Create the endpoint: */
	status = pjsip_endpt_create(&app.cp.factory, pj_gethostname()->ptr, &app.sip_endpt);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	return status;
}

/* Init SIP stack */
static pj_status_t init_sip() {
	pj_status_t status = -1;

	/* Add UDP/TCP transport. */
	{
	pj_sockaddr_in addr;
	pjsip_host_port addrname;
	const char *transport_type = NULL;

	pj_bzero(&addr, sizeof(addr));
	addr.sin_family = pj_AF_INET();
	addr.sin_addr.s_addr = 0;
	addr.sin_port = pj_htons((pj_uint16_t)app.local_port);

	if (app.local_addr.slen) {
		addrname.host = app.local_addr;
		addrname.port = 5060;
	}
	if (app.local_port != 0)
		addrname.port = app.local_port;

	if (0) {
#if defined(PJ_HAS_TCP) && PJ_HAS_TCP!=0
	} else if (app.use_tcp) {
		pj_sockaddr_in local_addr;
		pjsip_tpfactory *tpfactory;
		transport_type = "tcp";
		pj_sockaddr_in_init(&local_addr, 0, (pj_uint16_t)app.local_port);
		status = pjsip_tcp_transport_start(app.sip_endpt, &local_addr,
                                      app.thread_count, &tpfactory);
		if (status == PJ_SUCCESS) {
			app.local_addr = tpfactory->addr_name.host;
			app.local_port = tpfactory->addr_name.port;
		}
	} else if (app.use_tls)  {
		pjsip_tls_setting tls_settings;
		pjsip_tls_setting_default(&tls_settings);
		tls_settings.verify_server = PJ_FALSE;
		if (app.tls.cert.ptr)
			pj_strdup2(app.pool, &tls_settings.cert_file, app.tls.cert.ptr);
		if (app.tls.key.ptr)
			pj_strdup2(app.pool, &tls_settings.privkey_file, app.tls.key.ptr);
		if (app.tls.calist.ptr) {
			pj_strdup2(app.pool, &tls_settings.ca_list_file, app.tls.calist.ptr);
			pj_strdup2(app.pool, &tls_settings.ca_list_path, "");
			tls_settings.verify_server = PJ_TRUE;
		}
		if (app.tls.pass.ptr)
			pj_strdup2(app.pool, &tls_settings.password, app.tls.pass.ptr);

		pj_ssl_cipher ciphers[PJ_SSL_SOCK_MAX_CIPHERS];
		unsigned count = PJ_ARRAY_SIZE(ciphers);
		pj_ssl_cipher_get_availables(ciphers, &count);

		pjsip_tpfactory *tpfactory;
		transport_type = "tls";
		status = pjsip_tls_transport_start(app.sip_endpt, &tls_settings, &addr,
                     (app.local_addr.slen ? &addrname:NULL), app.thread_count, &tpfactory);
		if (status == PJ_SUCCESS) {
			app.local_addr = tpfactory->addr_name.host;
			app.local_port = tpfactory->addr_name.port;
		}

#endif
	} else {
		pjsip_transport *tp;
		// pjsip_str ip = {"127.0.1.1",9};
		transport_type = "udp";
		status = pjsip_udp_transport_start(app.sip_endpt, &addr,
            (app.local_addr.slen ? &addrname:NULL), app.thread_count, &tp);
		if (status == PJ_SUCCESS) {
			app.local_addr = tp->local_name.host;
			app.local_port = tp->local_name.port;
		}
	}
	if (status != PJ_SUCCESS) {
		app_perror(THIS_FILE, "Unable to start transport", status);
		return status;
	}

	if (app.client.callerid.ptr) {
		app.local_uri.ptr = pj_pool_alloc(app.pool, 128);
		app.local_uri.slen = pj_ansi_sprintf(app.local_uri.ptr,
					"<sip:%.*s@%.*s:%d;transport=%s>",
					(int)app.client.callerid.slen,
					app.client.callerid.ptr,
					(int)app.local_addr.slen,
					app.local_addr.ptr,
					app.local_port,
					transport_type);
		if (app.nat_ip.slen) {
			app.local_contact_nat.ptr = pj_pool_alloc(app.pool, 128);
			app.local_contact_nat.slen = pj_ansi_sprintf(app.local_contact_nat.ptr,
					"<sip:%.*s@%.*s:%d;transport=%s>",
					(int)app.client.callerid.slen,
					app.client.callerid.ptr,
					(int)app.nat_ip.slen,
					app.nat_ip.ptr,
					app.local_port,
					transport_type);
		}
	} else {
		app.local_uri.ptr = pj_pool_alloc(app.pool, 128);
		app.local_uri.slen = pj_ansi_sprintf(app.local_uri.ptr,
					"<sip:voip_perf@%.*s:%d;transport=%s>",
					(int)app.local_addr.slen,
					app.local_addr.ptr,
					app.local_port,
					transport_type);
		if (app.nat_ip.slen) {
			app.local_contact_nat.ptr = pj_pool_alloc(app.pool, 128);
			app.local_contact_nat.slen = pj_ansi_sprintf(app.local_contact_nat.ptr,
					"<sip:voip_perf@%.*s:%d;transport=%s>",
					(int)app.nat_ip.slen,
					app.nat_ip.ptr,
					app.local_port,
					transport_type);
		}
	}
	app.local_contact = app.local_uri;
	}

	/*
	 * Init transaction layer.
	 * This will create/initialize transaction hash tables etc.
	 */
	status = pjsip_tsx_layer_init_module(app.sip_endpt);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/*  Initialize UA layer. */
	status = pjsip_ua_init_module( app.sip_endpt, NULL );
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Initialize 100rel support */
	status = pjsip_100rel_init_module(app.sip_endpt);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/*  Init invite session module. */
	{
	pjsip_inv_callback inv_cb;

	/* Init the callback for INVITE session: */
	pj_bzero(&inv_cb, sizeof(inv_cb));
	inv_cb.on_state_changed = &call_on_state_changed;
	inv_cb.on_new_session = &call_on_forked;
	inv_cb.on_media_update = &call_on_media_update;
	inv_cb.on_tsx_state_changed = &call_on_tsx_state_changed;

	/* Initialize invite session module:  */
	status = pjsip_inv_usage_init(app.sip_endpt, &inv_cb);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, 1);
	}

	/* Register our call control module to receive incoming requests. */
	status = pjsip_endpt_register_module( app.sip_endpt, &mod_callcontrol);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Register our module to receive incoming requests. */
	status = pjsip_endpt_register_module( app.sip_endpt, &mod_test);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Register stateless server module */
	status = pjsip_endpt_register_module( app.sip_endpt, &mod_stateless_server);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Register default responder module */
	status = pjsip_endpt_register_module( app.sip_endpt, &mod_responder);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Register stateful server module */
	status = pjsip_endpt_register_module( app.sip_endpt, &mod_stateful_server);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	/* Register call server module */
	status = pjsip_endpt_register_module( app.sip_endpt, &mod_call_server);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	status = pjsip_endpt_register_module(app.sip_endpt, &mod_latency);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);
	PJ_LOG(3,(THIS_FILE, "latency module registered id[%d]", mod_latency.id));

	return PJ_SUCCESS;
}


/*
 * Destroy SIP
 */
static void destroy_app() {
	unsigned i;
	printf("shuting down, bye !\n");
	app.thread_quit = 1;
	for (i=0; i<app.thread_count; ++i) {
		if (app.thread[i]) {
			pj_thread_join(app.thread[i]);
			pj_thread_destroy(app.thread[i]);
			app.thread[i] = NULL;
		}
	}
	if (app.sip_endpt) {
		pjsip_endpt_destroy(app.sip_endpt);
		app.sip_endpt = NULL;
	}
	if (app.pool) {
		pj_pool_release(app.pool);
		app.pool = NULL;
		PJ_LOG(3,(THIS_FILE, "Peak memory size: %uMB",
				     app.cp.peak_used_size / 1000000));
		pj_caching_pool_destroy(&app.cp);
	}
	/* Shutdown PJLIB */
	pj_shutdown();
	exit(0);
}


/*
 * Init media stack.
 */
static pj_status_t init_media()
{
    unsigned	i;
    pj_uint16_t	rtp_port;
    pj_status_t	status;


    /* Initialize media endpoint so that at least error subsystem is properly
     * initialized.
     */
    status = pjmedia_endpt_create(&app.cp.factory, 
				  pjsip_endpt_get_ioqueue(app.sip_endpt), 0, 
				  &app.med_endpt);
    PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);


    /* Must register all codecs to be supported */
    pjmedia_codec_register_audio_codecs(app.med_endpt, NULL);

    /* Init dummy socket addresses */
    app.skinfo_cnt = 0;
    for (i=0, rtp_port=4000; i<PJ_ARRAY_SIZE(app.skinfo); ++i, rtp_port+=2) {
	pjmedia_sock_info *skinfo;

	skinfo = &app.skinfo[i];
	
	pj_sockaddr_in_init(&skinfo->rtp_addr_name.ipv4, &app.local_addr,
			    (pj_uint16_t)rtp_port);
	pj_sockaddr_in_init(&skinfo->rtp_addr_name.ipv4, &app.local_addr,
			    (pj_uint16_t)(rtp_port+1));
	app.skinfo_cnt++;
    }

    /* Generate dummy SDP */
    dummy_sdp_str.slen = pj_ansi_strlen(dummy_sdp_str.ptr);
    status = pjmedia_sdp_parse(app.pool, dummy_sdp_str.ptr, dummy_sdp_str.slen, 
			       &app.dummy_sdp);
    if (status != PJ_SUCCESS) {
	app_perror(THIS_FILE, "Error parsing dummy SDP", status);
	return status;
    }


    /* Done */
    return PJ_SUCCESS;
}


/* This is notification from the call about media negotiation
 * status. This is called for client calls only.
 */
static void call_on_media_update( pjsip_inv_session *inv,
				  pj_status_t status)
{
    if (status != PJ_SUCCESS) {
	pjsip_tx_data *tdata;
	pj_status_t status2;
	status2 = pjsip_inv_end_session(inv, PJSIP_SC_UNSUPPORTED_MEDIA_TYPE,
				       NULL, &tdata);
	if (status2 == PJ_SUCCESS && tdata)
	    status2 = pjsip_inv_send_msg(inv, tdata);
    }
}

static void status_check_period(pj_bool_t end_now) {
	pj_time_val period;
	pj_gettimeofday(&period);
	int seconds = period.sec;
	PJ_TIME_VAL_SUB(period, app.status_metrics_period_start);
	if (end_now || period.sec >= app.status_metrics_period_duration) {
		pj_gettimeofday(&app.status_metrics_period_start);
		print_detailed_response_code_received(PJ_TRUE);
	}
}

static void metric_check_period(pj_bool_t end_now) {
	pj_time_val period;
	pj_gettimeofday(&period);
	int seconds = period.sec;
	PJ_TIME_VAL_SUB(period, app.latency_metrics_period_start);

	if (end_now || period.sec >= app.latency_metrics_period_duration) {
		pj_gettimeofday(&app.latency_metrics_period_start);
		fprintf(log_stats_output, "%d,INVITE,%d,%.2f,%.2f,%d,%d,%.2f,%.2f,%d,%d,%.2f,%.2f,%d\n", seconds,
				app.latency_metrics[0].count, app.latency_metrics[0].average, app.latency_metrics[0].stdev, app.latency_metrics[0].max,
				app.latency_metrics[1].count, app.latency_metrics[1].average, app.latency_metrics[1].stdev, app.latency_metrics[1].max,
				app.latency_metrics[2].count, app.latency_metrics[2].average, app.latency_metrics[2].stdev, app.latency_metrics[2].max);
		PJ_LOG(1, (THIS_FILE, "metric_period[%lld]job:count[%d/%d]submitted[%d]connected[%d]window[%d]",
	                  period.sec, app.client.job_finished, app.client.job_count, app.client.job_submitted, app.client.job_connected, app.client.job_window));
		PJ_LOG(1, (THIS_FILE, "INVITE-100 count[%d] avg[%.1fms]std[%0.1fms]max[%dms]",
	                   app.latency_metrics[0].count, app.latency_metrics[0].average, app.latency_metrics[0].stdev, app.latency_metrics[0].max));
		PJ_LOG(1, (THIS_FILE, "INVITE-180 count[%d] avg[%.1fms]std[%0.1fms]max[%dms]",
	                   app.latency_metrics[1].count, app.latency_metrics[1].average, app.latency_metrics[1].stdev, app.latency_metrics[1].max));
		PJ_LOG(1, (THIS_FILE, "INVITE-200 count[%d] avg[%.1fms]std[%0.1fms]max[%dms]",
	                   app.latency_metrics[2].count, app.latency_metrics[2].average, app.latency_metrics[2].stdev, app.latency_metrics[2].max));
		app.latency_metrics[0].min = 0;
		app.latency_metrics[0].max = 0;
		app.latency_metrics[0].count = 0;
		app.latency_metrics[0].stdev = 0.0f;
		app.latency_metrics[0].average = 0.0f;
		app.latency_metrics[1].min = 0;
		app.latency_metrics[1].max = 0;
		app.latency_metrics[1].count = 0;
		app.latency_metrics[1].stdev = 0.0f;
		app.latency_metrics[1].average = 0.0f;
		app.latency_metrics[2].min = 0;
		app.latency_metrics[2].max = 0;
		app.latency_metrics[2].count = 0;
		app.latency_metrics[2].stdev = 0.0f;
		app.latency_metrics[2].average = 0.0f;
	}
}

static void metric_update(pjsip_transaction *tsx, unsigned status_code, pj_str_t *method, pj_time_val start) {
	pj_time_val now;

	int idx;
	float current_average, current_q;
	if (!app.latency_metrics_period_duration)
		return;

	pj_gettimeofday(&now);
	if(PJ_TIME_VAL_LT(now,start)) {
		PJ_LOG(1, (THIS_FILE, "metric_update tsx[%d] [%.*s][%d] start[%lld.%lld] now[%lld.%lld]", tsx->state, method->slen, method->ptr, status_code, start.sec, start.msec, now.sec, now.msec));
		return;
	}
	PJ_TIME_VAL_SUB(now, start);
	int latency = now.msec;
	if (now.sec)
		latency += now.sec*1000;
	if (status_code == 100) {
		idx = 0;
	} else if (status_code == 180 || status_code == 183) {
		idx = 1;
	} else if (status_code == 200) {
		idx = 2;
	} else {
		return;
	}

	app.latency_metrics[idx].count++;
	if (app.latency_metrics[idx].count == 1) {
		app.latency_metrics[idx].stdev = 0.0f;
		app.latency_metrics[idx].last_q = 0.0f;
		app.latency_metrics[idx].max = latency;
		app.latency_metrics[idx].min = latency;
		app.latency_metrics[idx].average = latency;
	}
	if (app.latency_metrics[idx].min > latency)
		app.latency_metrics[idx].min = latency;
	if (app.latency_metrics[idx].max < latency)
		app.latency_metrics[idx].max = latency;

	/* standard deviation from global average */
	if (app.latency_metrics[idx].count > 1) {
		current_average = app.latency_metrics[idx].average + (latency - app.latency_metrics[idx].average) / app.latency_metrics[idx].count;
		current_q = app.latency_metrics[idx].last_q + (latency - app.latency_metrics[idx].average)*(latency - current_average);
		app.latency_metrics[idx].average = current_average;
		app.latency_metrics[idx].last_q = current_q;
		app.latency_metrics[idx].stdev = sqrt(current_q/(app.latency_metrics[idx].count-1));
	}
	PJ_LOG(4, (THIS_FILE, "metric_update [%lld.%lld] [%.*s][%d]count[%d]value[%d]avg[%.4f]std[%.4f]",
                               now.sec, now.msec, method->slen, method->ptr, status_code,
                               app.latency_metrics[idx].count, latency, app.latency_metrics[idx].average, app.latency_metrics[idx].stdev));
	metric_check_period(PJ_FALSE);
}

// pjsip_inv_callback inv_cb;
    /**
     * This callback is called whenever any transactions within the session
     * has changed their state. Application MAY implement this callback, 
     * e.g. to monitor the progress of an outgoing request, or to send
     * response to unhandled incoming request (such as INFO).
     *
     * This callback is optional.
     *
     * @param inv	The invite session.
     * @param tsx	The transaction, which state has changed.
     * @param e		The event which has caused the transation state's
     *			to change.
     */
    //void (*on_tsx_state_changed)(pjsip_inv_session *inv, pjsip_transaction *tsx, pjsip_event *e);
static void call_on_tsx_state_changed(pjsip_inv_session *inv, pjsip_transaction *tsx, pjsip_event *e) {
	if (!app.client.dst_uri.slen)
		return; // server mode does not reun this code
	PJ_LOG(4, (THIS_FILE, "call_on_tsx_state_changed call[%d] transaction[%d] module[%s|%d|%p]", inv->state, tsx->state, tsx->tsx_user->name, tsx->tsx_user->id, tsx->mod_data[mod_latency.id]));
	if (tsx->method.id != PJSIP_INVITE_METHOD)
		return;
	if (tsx->state == PJSIP_TSX_STATE_CALLING) {
		pj_lock_acquire(app.stats_lock);
		if (inv->mod_data[mod_latency.id])
			PJ_LOG(1, (THIS_FILE, "inv->mod_data[mod_latency.id]"));
		pj_time_val *start = (pj_time_val *) pj_pool_zalloc(inv->dlg->pool, sizeof(struct pj_time_val));
		pj_gettimeofday(start);
		inv->mod_data[mod_latency.id] = start;
		if (start->msec > 1000)
			PJ_LOG(1, (THIS_FILE, "invalid start[%lld.%lld]", start->sec, start->msec));
		pj_lock_release(app.stats_lock);
	} else {
		if (inv->state < 6) {
			pj_lock_acquire(app.stats_lock);
			pj_time_val *tmp = (pj_time_val *) inv->mod_data[mod_latency.id];
			if (!tmp) {
				PJ_LOG(4, (THIS_FILE, "tx_state[%d] inv_state[%d] no data for the transaction.",
							tsx->state, inv->state));
				pj_lock_release(app.stats_lock);
				return;
			}
			if (tmp->msec > 1000)
				PJ_LOG(1, (THIS_FILE, "invalid tsx_com[%d] tmp[%lld.%lld]", tsx->mod_data[mod_test.id], tmp->sec, tmp->msec));
			pj_time_val start = *tmp;
			metric_update(tsx, tsx->status_code, &tsx->method.name, start);
			pj_lock_release(app.stats_lock);
		}
	}
	return;
}


/* This is notification from the call when the call state has changed.
 * This is called for client calls only.
 */
static void call_on_state_changed( pjsip_inv_session *inv, pjsip_event *e) {
	PJ_UNUSED_ARG(e);
	/* Bail out if the session has been counted before */
	if (inv->mod_data[mod_test.id] != NULL)
		return;
	/* Bail out if this is not an outgoing call */
	if (inv->role != PJSIP_UAC_ROLE)
		return;

	if (inv->state == PJSIP_INV_STATE_CONFIRMED) {
		pjsip_tx_data *tdata;
		pj_status_t status;

		/* Simulate call disconnection delay */
		if (app.client.call_duration) {
			outbound_call_t *call = pj_pool_zalloc(inv->dlg->pool, sizeof(struct call));

			call->inv = inv;
			pj_time_val delay;
			call->hangup_timer.id = 1;
			call->hangup_timer.user_data = call;
			call->hangup_timer.cb = &hangup_timer_cb;

			delay.sec = app.client.call_duration;
			delay.msec = 0;
			pj_time_val_normalize(&delay);
			PJ_LOG(4, (THIS_FILE, "call_on_state_changed duration[%d] call[%d] ", delay.sec, inv->state));
			pjsip_endpt_schedule_timer(app.sip_endpt, &call->hangup_timer, &delay);
			inv->mod_data[mod_callcontrol.id] = &call->hangup_timer;
		} else {
			inv->mod_data[mod_callcontrol.id] = NULL;
			status = pjsip_inv_end_session(inv, PJSIP_SC_OK, NULL, &tdata);
			if (status == PJ_SUCCESS && tdata)
				status = pjsip_inv_send_msg(inv, tdata);
		}
	} else if (inv->state == PJSIP_INV_STATE_CONNECTING) {
		report_completion(200, &e->body.tsx_state.tsx->method.name, &inv->dlg->call_id->id);
	} else if (inv->state == PJSIP_INV_STATE_DISCONNECTED) {
		report_completion(inv->cause, &e->body.tsx_state.tsx->method.name, &inv->dlg->call_id->id);
		inv->mod_data[mod_test.id] = (void*)(pj_ssize_t)1;
		if (inv->mod_data[mod_callcontrol.id]) {
			PJ_LOG(4, (THIS_FILE, "cancelling hangup timer"));
			pjsip_endpt_cancel_timer(app.sip_endpt, (pj_timer_entry *)inv->mod_data[mod_callcontrol.id]);
		}
	}
}

/* Not implemented for now */
static void call_on_forked(pjsip_inv_session *inv, pjsip_event *e) {
	/* Do nothing */
	PJ_UNUSED_ARG(inv);
	PJ_UNUSED_ARG(e);
}

/* Make outgoing call */
static pj_status_t make_call(const pj_str_t *dst_uri) {
	struct call *call;
	pjsip_dialog *dlg;
	pjmedia_sdp_session *sdp;
	pjsip_tx_data *tdata;
	pj_status_t status;
	pj_time_val now, after;

	pj_gettimeofday(&now); // profiling check

	pj_str_t target_uri;
	pj_str_t local_uri;

	extra_header_t *extra_headers_user = NULL;
	int extra_headers_user_count = 0;
	// json users list
	if (app.client.users_count) {
		user_t *u = &app.client.users[app.client.current_user];
		target_uri.ptr = strndup(u->ruri.ptr, u->ruri.slen);
		target_uri.slen = u->ruri.slen;
		if(u->furi.slen != 0){
			local_uri.ptr = strndup(u->furi.ptr, u->furi.slen);
			local_uri.slen = u->furi.slen;
		} else {
			local_uri.ptr = strndup(app.local_uri.ptr, app.local_uri.slen);
			local_uri.slen = app.local_uri.slen;
		}
		extra_headers_user = u->headers;
		extra_headers_user_count = u->headers_count;
		app.client.current_user++;
		if (app.client.current_user >= app.client.users_count)
			app.client.current_user = 0;
	} else {
		target_uri.ptr = strndup(dst_uri->ptr, dst_uri->slen);
		target_uri.slen = dst_uri->slen;

		local_uri.ptr = strndup(app.local_uri.ptr, app.local_uri.slen);
		local_uri.slen = app.local_uri.slen;

		extra_headers_user_count = 0;
	}

	// random calledid
	char digit[11] = "0123456789";
	char c[2] = "?";
	char *ret;
	do {
		ret = strstr(target_uri.ptr, c);
			if (ret) {
			ret[0] = digit[rand()%10];
		}
	} while (ret);

	do {
		ret = strstr(local_uri.ptr, c);
			if (ret) {
			ret[0] = digit[rand()%10];
		}
	} while (ret);

	// contact same as from-uri
	app.local_contact = local_uri;

	/* Create UAC dialog */
	status = pjsip_dlg_create_uac( pjsip_ua_instance(), 
				   &local_uri,		/* local URI	    */
				   &app.local_contact,	/* local Contact    */
				   &target_uri,		/* remote URI	    */
				   NULL,		/* remote target    */
				   &dlg);		/* dialog	    */
	if (status != PJ_SUCCESS) {
		return status;
	}

	if (app.disable_connection_reuse)
		dlg->tp_sel.disable_connection_reuse = PJ_TRUE;

	/* Create call */
	call = pj_pool_zalloc(dlg->pool, sizeof(struct call));

	/* Create SDP */
	if (app.real_sdp) {
		status = pjmedia_endpt_create_sdp(app.med_endpt, dlg->pool, 1, app.skinfo, &sdp);
		if (status != PJ_SUCCESS) {
			pjsip_dlg_terminate(dlg);
			return status;
		}
	} else {
		sdp = app.dummy_sdp;
	}

	/* Create the INVITE session. */
	status = pjsip_inv_create_uac( dlg, sdp, 0, &call->inv);
	if (status != PJ_SUCCESS) {
		pjsip_dlg_terminate(dlg);
		return status;
	}
	if (pj_list_empty(&app.route_set) == 0 ) {
		pjsip_dlg_set_route_set(dlg, &app.route_set);
	}


	int x, idx = 0;
	extra_header_t *extra_headers = app.client.extra_headers;
	for (x=0; x<app.client.custom_headers_count ; x++) {
		pjsip_generic_string_hdr *h;
		h = pjsip_generic_string_hdr_create(dlg->pool, &extra_headers->name, &extra_headers->value);
		pj_list_push_back(&dlg->inv_hdr, h);
		extra_headers++;
	}

	PJ_LOG(4, (THIS_FILE, "user extra headers[%d]\n", extra_headers_user_count));
	for (x=0; x<extra_headers_user_count ; x++) {
		pjsip_generic_string_hdr *h;
		h = pjsip_generic_string_hdr_create(dlg->pool, &extra_headers_user->name, &extra_headers_user->value);
		pj_list_push_back(&dlg->inv_hdr, h);
		extra_headers_user++;
	}


	/* Create initial INVITE request.
	 * This INVITE request will contain a perfectly good request and 
	 * an SDP body as well. */
	status = pjsip_inv_invite(call->inv, &tdata);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);
	{
	pjsip_msg *msg = tdata->msg;
	PJ_LOG(4, (THIS_FILE, "make_call msg[%d]", msg->type ));
	}

	/* Send initial INVITE request.
	 * From now on, the invite session's state will be reported to us
	 * via the invite session callbacks. */
	status = pjsip_inv_send_msg(call->inv, tdata);
	PJ_ASSERT_RETURN(status == PJ_SUCCESS, status);

	pj_gettimeofday(&after); // profiling check
	PJ_TIME_VAL_SUB(after, now);
	if (after.msec >1) PJ_LOG(1, (THIS_FILE, "delay %s check:[%d.%d]", __FUNCTION__, (int)after.sec, (int)after.msec));
	return PJ_SUCCESS;
}


/*
 * Verify that valid SIP url is given.
 */
static pj_status_t verify_sip_url(const char *c_url) {
	pjsip_uri *p;
	pj_pool_t *pool;
	char *url;
	pj_size_t len = (c_url ? pj_ansi_strlen(c_url) : 0);

	if (!len) return -1;

	pool = pj_pool_create(&app.cp.factory, "check%p", 1024, 0, NULL);
	if (!pool) return PJ_ENOMEM;

	url = pj_pool_alloc(pool, len+1);
	pj_ansi_strcpy(url, c_url);
	url[len] = '\0';

	p = pjsip_parse_uri(pool, url, len, 0);
	if (!p || pj_stricmp2(pjsip_uri_get_scheme(p), "sip") != 0)
	p = NULL;

	pj_pool_release(pool);
	return p ? 0 : -1;
}


static void usage(void) {
	printf(
	"Usage:\n"
	"   voip_perf [OPTIONS]        -- to start as server\n"
	"   voip_perf [OPTIONS] URL    -- to call server (possibly itself)\n"
	"\n"
	"where:\n"
	"   URL                     The SIP URL to be contacted.\n"
	"                           '?' will be replaced by random digits from 0-9\n"
	"\n"
	"Client options:\n"
	"   --proxy=IP              Set the Route host part of the SIP proxy\n"
	"   --method=METHOD         Set test method (set to INVITE for call benchmark)\n"
        "                           [default: OPTIONS]\n"
	"   --caller-id             Set the caller-id '?' will be replaced by random digits from 0-9\n"
	"   --count=N               Set total number of requests to initiate\n"
	"                           [default=%d]\n"
	"   --stateless             Set to operate in stateless mode\n"
	"                           [default: stateful]\n"
	"   --timeout=SEC           Set client timeout [default=60 sec]\n"
	"   --window=COUNT          Set maximum outstanding job [default: %d]\n"
	"   --call-per-second=COUNT Set maximum amount of call per second [default: 100]\n"
	"   --interval=SEC          Set the reporting interval of the measurement [default: 1 sec]\n"
	"   --latency_file=./latency.csv  csv measurement output file\n"
	"\n"
	"SDP options (client and server):\n"
	"   --real-sdp              Generate real SDP from pjmedia, and also perform\n"
	"                           proper SDP negotiation [default: dummy]\n"
	"\n"
	"Client and Server options:\n"
	"   --config=filename.json  Set the json config file name\n"
	"   --nat-etexnal-ip=IP     Set the public IP used to connect to this voip-perf server\n"
	"   --local-port=PORT       Set local port [default: 5060]\n"
	"   --disable-connection-reuse  Create a new socket\n"
	"   --use-tcp               Use TCP instead of UDP. Note that when started as\n"
	"                           client, you must add ;transport=tcp parameter to URL\n"
	"                           [default: no]\n"
	"   --use-tls               Use TLS instead of UDP. Note that when started as\n"
	"                           client, you must add ;transport=tls parameter to URL\n"
	"                           [default: no]\n"
	"   --tls-cert              certificate (pem format)\n"
	"   --tls-key               certificate private key\n"
	"   --tls-pass              private key password\n"
	"   --tls-calist            trusted CA list (pem format)\n"
	"   --thread-count=N        Set number of worker threads [default=1]\n"
	"   --trying                Send 100/Trying response (server, default no)\n"
	"   --ringing               Send 180/Ringing response (server, default no)\n"
	"   --delay=MS              Delay answering call by MS (server, default no)\n"
	"   --duration=S            Duration of the call before disconnecting in S (client, default 0)\n"
	"   --console               Console mode\n"
	"\n"
	"Misc options:\n"
	"   --help                  Display this screen\n"
	"   --verbose               Verbose logging (put more than once for even more)\n"
	"   --version               Output version information\n"
	"\n"
	"When started as server, voip_perf can be contacted on the following URIs:\n"
	"   - sip:0@server-addr     To handle requests statelessly.\n"
	"   - sip:1@server-addr     To handle requests statefully.\n"
	"   - sip:2@server-addr     To handle INVITE call.\n",
	DEFAULT_COUNT, JOB_WINDOW);
}


static int my_atoi(const char *s) {
	pj_str_t ss = pj_str((char*)s);
	return pj_strtoul(&ss);
}


static int add_proxy_route(const char *s) {
	pjsip_route_hdr *route;
	const pj_str_t hname = { "Route", 5 };
	int len = strlen(s);
	len += 7;
	char *uri = pj_pool_zalloc(app.pool, sizeof(char) * len);
	snprintf(uri, len+1, "sip:%s;lr", s);
	printf("adding Proxy : [%s|%d]\n", uri, len);
	route = pjsip_parse_hdr(app.pool, &hname, uri, strlen(uri), NULL);
	PJ_ASSERT_RETURN(route != NULL, 0);
	pj_list_push_back(&app.route_set, route);
	return 1;
}


static void load_json_config_replies (json_t *responses) {
	int i=0;
	app.server.responses_count = (int)json_array_size(responses);
	app.server.responses = pj_pool_zalloc(app.pool, sizeof(responses_t) * app.server.responses_count);
	responses_t *rep = app.server.responses;
	for (i=0;i< app.server.responses_count ;i++) {
		json_t *e = json_array_get(responses, i);
		if (e) {
			void *iter = json_object_iter(e);
			while (iter) {
				const char *key = json_object_iter_key(iter);
				json_t *v = json_object_iter_value(iter);
				if (strcmp(key, "code") == 0) {
					if (!json_is_integer(v)) goto err;
					rep->code = (int)json_integer_value(v);
				} else if (strcmp(key, "reason") == 0) {
					if (!json_is_string(v)) goto err;
					pj_strdup2(app.pool, &rep->reason, json_string_value(v));
				} else if (strcmp(key, "probability") == 0) {
					if (!json_is_real(v)) goto err;
					rep->prob = json_real_value(v)*100;
					if (rep->prob > 100) rep->prob = 100;
					if (rep->prob < 1) rep->prob = 1;
				}
				iter = json_object_iter_next(e, iter);
			}
			printf("[%d %.*s] [%d/100]\n", rep->code, (int)rep->reason.slen, rep->reason.ptr, rep->prob);
			rep++;
		}
	}
	return;
err:
	app.server.responses_count = 0;
	printf("[%s] error loading config\n", __FUNCTION__);
}


static void load_json_config_users(json_t *users_json) {
	if (!users_json) return;
	app.client.users_count = json_array_size(users_json);
	app.client.users = pj_pool_zalloc(app.pool, sizeof(user_t) * app.client.users_count);
	user_t *users = app.client.users;
	if (app.client.users_count > 0) app.client_mode = PJ_TRUE;
	printf("list users x%d, enabling client mode\n", app.client.users_count);
	json_t *e;
	int i=0;
	while (e = json_array_get(users_json, i)) {
		void *iter = json_object_iter(e);
		while (iter) {
			const char *key = json_object_iter_key(iter);
			if (strcmp(key, "ruri") == 0) {
				json_t *v = json_object_iter_value(iter);
				pj_strdup2(app.pool, &users->ruri, json_string_value(v));
				PJ_LOG(5,(THIS_FILE,"user[%s: %s]", key, app.client.users[i].ruri));
			} else if (strcmp(key, "extra-headers") == 0) {
				json_t *v = json_object_iter_value(iter);
				users->headers = load_json_config_extra_headers(v, &users->headers_count);
			} else if (strcmp(key, "furi") == 0) {
				json_t *v = json_object_iter_value(iter);
				pj_strdup2(app.pool, &users->furi, json_string_value(v));
				PJ_LOG(5,(THIS_FILE,"user[%s: %s]", key, app.client.users[i].furi));
			}
			iter = json_object_iter_next(e, iter);
			if (!iter) users++;
		}
		i++;
	}
}

extra_header_t * load_json_config_extra_headers(json_t *extra_headers_json, int *count) {
	extra_header_t *extra_headers = NULL;
	extra_header_t *tmp = NULL;

	if (!extra_headers_json) return extra_headers;
	*count = 0;
	void *iter = json_object_iter(extra_headers_json);
	while (iter) {
		iter = json_object_iter_next(extra_headers_json, iter);
		(*count)++;
	}
	printf(">> extra-headers x%d\n", *count);
	if (*count == 0) return extra_headers;
	iter = json_object_iter(extra_headers_json);
	extra_headers = (extra_header_t *) pj_pool_zalloc(app.pool, sizeof(extra_header_t) * (*count));
	tmp = extra_headers;
	while (iter) {
		const char *key = json_object_iter_key(iter);
		json_t *v = json_object_iter_value(iter);
		if (json_is_string(v)) {
			printf("extra-header[%s: %s]\n", key, json_string_value(v));
			pjsip_generic_string_hdr *h;
			pj_str_t hname, hvalue;
			pj_strdup2(app.pool, &tmp->name, key);
			pj_strdup2(app.pool, &tmp->value, json_string_value(v));
		}
		iter = json_object_iter_next(extra_headers_json, iter);
		if (iter) tmp++;
	}
	return extra_headers;
err:
	app.client.custom_headers_count = 0;
	printf("[%s] error loading config\n", __FUNCTION__);
}

static int load_json_config (char *fn) {
	json_t *json;
	json_error_t error;

	json = json_load_file(fn, 0, &error);
	if(!json) {
		if (strcmp(fn,CONFIG_DEFAULT_FN) == 0) {
			PJ_LOG(4,(THIS_FILE,"no default json config[%s]", fn));
			return 0;
		} else {
			PJ_LOG(4,(THIS_FILE,"error loading json config[%s]", fn));
			return -1;
		}
	} else {
		PJ_LOG(4,(THIS_FILE,"loading json config[%s]", fn));
		const char *key;
		json_t *value;
		void *iter = json_object_iter(json);
		while(iter) {
			key = json_object_iter_key(iter);
			value = json_object_iter_value(iter);
			if (json_is_object(value)) {
				printf("[%s][object]\n", key);
			} else if (json_is_array(value)) {
				int i=0;
				if (strcmp(key, "server") == 0) {
					printf("server params\n");
					for (i=0;i<(int)json_array_size(value);i++) {
						json_t *e = json_array_get(value, i);
						if (e) {
							void *server_iter = json_object_iter(e);
							const char *server_key = json_object_iter_key(server_iter);
							json_t *server_value = json_object_iter_value(server_iter);
							if (strcmp(server_key, "response") == 0) {
								if (json_is_array(server_value)) load_json_config_replies(server_value);
							}
						}
					}
				} else if (strcmp(key, "client") == 0)  {
					printf("client params\n");
					for (i=0;i<(int)json_array_size(value);i++) {
						json_t *e = json_array_get(value, i);
						if (e) {
							void *client_iter = json_object_iter(e);
							const char *client_key = json_object_iter_key(client_iter);
							json_t *client_value = json_object_iter_value(client_iter);
							if (strcmp(client_key, "extra-headers") == 0) {
								app.client.extra_headers = load_json_config_extra_headers(client_value, &app.client.custom_headers_count);
							}
							if (strcmp(client_key, "users") == 0) {
								if (json_is_array(client_value)) load_json_config_users(client_value);
							}
						}
					}
				}
				printf("[%s][array]size[%d]\n", key, (int)json_array_size(value));
			}
			/* use key and value ... */
			iter = json_object_iter_next(json, iter);
		}
	}
	return 0;
}

static pj_status_t init_options(int argc, char *argv[]) {
	enum { OPT_THREAD_COUNT = 127, OPT_HELP, OPT_CFG_FN, OPT_NAT_IP, OPT_STATELESS, OPT_LOCAL_PORT,
               OPT_METHOD, OPT_LATENCY_FN, OPT_COUNT, OPT_REAL_SDP, OPT_CPS,
               OPT_INTERVAL, OPT_VERBOSE, OPT_TIMEOUT, OPT_PROXY, OPT_CONSOLE_MODE,
               OPT_DURATION, OPT_DELAY, OPT_WINDOW, OPT_CALLERID, OPT_TRYING, OPT_RINGING,
               OPT_TLS_CERT, OPT_USE_TCP, OPT_USE_TLS, OPT_DISABLE_CONNECTION_REUSE, OPT_TLS_KEY,
               OPT_TLS_PASS, OPT_TLS_CALIST, OPT_RURI, OPT_VERSION
        };
	struct pj_getopt_option long_options[] = {
		{ "config",	    1, 0, OPT_CFG_FN },
		{ "nat-etexnal-ip", 1, 0, OPT_NAT_IP },
		{ "local-port",	    1, 0, OPT_LOCAL_PORT },
		{ "caller-id",	    1, 0, OPT_CALLERID },
		{ "count",	    1, 0, OPT_COUNT },
		{ "thread-count",   1, 0, OPT_THREAD_COUNT },
		{ "console",        0, 0, OPT_CONSOLE_MODE },
		{ "method",	    1, 0, OPT_METHOD },
		{ "latency_file",	    1, 0, OPT_LATENCY_FN },
		{ "proxy",	    1, 0, OPT_PROXY },
		{ "help",	    0, 0, OPT_HELP },
		{ "stateless",	    0, 0, OPT_STATELESS },
		{ "timeout",	    1, 0, OPT_TIMEOUT },
		{ "interval",	    1, 0, OPT_INTERVAL },
		{ "call-per-second", 1, 0, OPT_CPS },
		{ "real-sdp",	    0, 0, OPT_REAL_SDP },
		{ "verbose",        0, 0, OPT_VERBOSE },
		{ "use-tcp",	    0, 0, OPT_USE_TCP },
		{ "use-tls",	    0, 0, OPT_USE_TLS },
		{ "disable-connection-reuse",    0, 0, OPT_DISABLE_CONNECTION_REUSE },
		{ "window",	    1, 0, OPT_WINDOW },
		{ "delay",	    1, 0, OPT_DELAY },
		{ "duration",	    1, 0, OPT_DURATION },
		{ "trying",	    0, 0, OPT_TRYING },
		{ "ruri",	    0, 0, OPT_RURI },
		{ "ringing",	    0, 0, OPT_RINGING },
		{ "version",	    0, 0, OPT_VERSION },
		{ "tls-cert",	    1, 0, OPT_TLS_CERT },
		{ "tls-key",	    1, 0, OPT_TLS_KEY },
		{ "tls-pass",	    1, 0, OPT_TLS_PASS },
		{ "tls-calist",	    1, 0, OPT_TLS_CALIST },
		{ NULL, 0, 0, 0 },
	};

	int c;
	int option_index;

	/* Init default application configs */
	app.local_port = 5060;
	app.thread_count = 1;
	app.client.job_count = DEFAULT_COUNT;
	app.client.cps = 100;
	app.client.method = *pjsip_get_options_method();
	app.client.job_window = c = JOB_WINDOW;
	app.client.timeout = 60;
	app.client.custom_headers_count = 0;
	app.client.extra_headers = NULL;
	app.latency_metrics_period_duration = 0;
	app.status_metrics_period_duration = 0;
	app.log_level = 3;
	app.server.responses = NULL;
	app.server.responses_count = 0;
	app.server.call_duration = 10;
	pj_list_init(&app.route_set);
	pjsip_cfg()->endpt.disable_tcp_switch=PJ_TRUE;
	#define LATENCY_DEFAULT_FN "./latency.csv"
	app.latency_fn = pj_str(LATENCY_DEFAULT_FN);

	app.cfg_fn = pj_str(CONFIG_DEFAULT_FN);
	/* Parse options */
	pj_optind = 0;
	while((c=pj_getopt_long(argc,argv, "", long_options, &option_index))!=-1) 
	{
		switch (c) {
		case OPT_LOCAL_PORT:
			app.local_port = my_atoi(pj_optarg);
			if (app.local_port < 0 || app.local_port > 65535) {
				PJ_LOG(3,(THIS_FILE, "Invalid --local-port %s", pj_optarg));
				return -1;
			}
			PJ_LOG(3,(THIS_FILE,"local_port[%d]", app.local_port));
			break;
		case OPT_PROXY:
			add_proxy_route(pj_optarg);
			break;
		case OPT_COUNT:
			app.client.job_count = my_atoi(pj_optarg);
			if (app.client.job_count > pjsip_cfg()->tsx.max_count)
				PJ_LOG(3,(THIS_FILE,
				  "Warning: --count value (%d) exceeds maximum "
				  "transaction count (%d)", app.client.job_count,
				  pjsip_cfg()->tsx.max_count));
			break;
		case OPT_THREAD_COUNT:
			app.thread_count = my_atoi(pj_optarg);
			if (app.thread_count < 1 || app.thread_count > 16) {
				PJ_LOG(3,(THIS_FILE, "Invalid --thread-count %s", pj_optarg));
				return -1;
			}
			break;
		case OPT_METHOD:
			{
			pj_str_t temp = pj_str((char*)pj_optarg);
			pjsip_method_init_np(&app.client.method, &temp);
			PJ_LOG(3,(THIS_FILE, "method:[%s]", temp.ptr ));
			}
			break;
		case OPT_LATENCY_FN:
			{
			app.latency_fn = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "latency file name:[%s]", app.latency_fn.ptr));
			}
			break;
		case OPT_HELP:
			usage();
			return -1;
		case OPT_VERSION:
			printf("voip_perf version:%s\n", VERSION);
			return -1;
		case OPT_STATELESS:
			app.client.stateless = PJ_TRUE;
			break;
		case OPT_TLS_CERT:
			{
			app.tls.cert = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "tls cert:[%s][%d]", app.tls.cert.ptr, app.tls.cert.slen ));
			}
			break;
		case OPT_TLS_KEY:
			app.tls.key = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "tls key:[%s][%d]", app.tls.key.ptr, app.tls.key.slen ));
			break;
		case OPT_TLS_PASS:
			app.tls.pass = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "tls pass:[x][%d]", app.tls.pass.slen ));
			break;
		case OPT_TLS_CALIST:
			app.tls.calist = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "tls ca list:[%s][%d]", app.tls.calist.ptr, app.tls.calist.slen ));
			break;
		case OPT_CFG_FN:
			{
			app.cfg_fn = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "json config filename:[%s][%d]", app.cfg_fn.ptr, app.cfg_fn.slen ));
			}
			break;
		case OPT_NAT_IP:
			{
			app.nat_ip = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "nat external IP:[%s][%d]", app.nat_ip.ptr, app.nat_ip.slen ));
			}
			break;
		case OPT_CALLERID:
			{
			app.client.callerid = pj_str((char*)pj_optarg);
			PJ_LOG(3,(THIS_FILE, "callerid:[%s][%d]", app.client.callerid.ptr, app.client.callerid.slen ));
			}
			break;
		case OPT_REAL_SDP:
			app.real_sdp = 1;
			break;
		case OPT_VERBOSE:
			app.log_level++;
			break;
		case OPT_TIMEOUT:
			app.client.timeout = my_atoi(pj_optarg);
			if (app.client.timeout > 86400) {
				PJ_LOG(3,(THIS_FILE, "Invalid --timeout %s", pj_optarg));
				return -1;
			}
			break;
		case OPT_INTERVAL:
			app.latency_metrics_period_duration = my_atoi(pj_optarg);
			app.status_metrics_period_duration = my_atoi(pj_optarg);
			if (app.latency_metrics_period_duration < 1) {
				PJ_LOG(3,(THIS_FILE, "Invalid --interval %s", pj_optarg));
				return -1;
			}
			break;
		case OPT_CPS:
			app.client.cps = my_atoi(pj_optarg);
			if (app.client.cps < 1 || app.client.cps >= 10000) {
				PJ_LOG(3,(THIS_FILE, "Invalid --call-per-second %s", pj_optarg));
				return -1;
			}
			break;
		case OPT_WINDOW:
			app.client.job_window = my_atoi(pj_optarg);
			if (app.client.job_window <= 0) {
				PJ_LOG(3,(THIS_FILE, "Invalid --window %s", pj_optarg));
				return -1;
			}
			break;
		case OPT_USE_TCP:
			PJ_LOG(3,(THIS_FILE, "using tcp transport"));
			app.use_tcp = PJ_TRUE;
			break;
		case OPT_USE_TLS:
			PJ_LOG(3,(THIS_FILE, "using tls transport"));
			app.use_tls = PJ_TRUE;
			break;
		case OPT_DISABLE_CONNECTION_REUSE:
			PJ_LOG(3,(THIS_FILE, "disabling connection reuse"));
			app.disable_connection_reuse = PJ_TRUE;
			break;
		case OPT_DELAY:
			app.server.delay = my_atoi(pj_optarg);
			if (app.server.delay > 36000) {
			PJ_LOG(3,(THIS_FILE, "I think --delay %s is too long", pj_optarg));
				return -1;
			}
			break;
		case OPT_DURATION:
			app.client.call_duration = my_atoi(pj_optarg);
			if (app.client.call_duration > 3600) {
			PJ_LOG(3,(THIS_FILE, "I think --duration %s is too long", pj_optarg));
				return -1;
			}
			break;
		case OPT_CONSOLE_MODE:
			app.server.console_mode = 1;
			break;
		case OPT_TRYING:
			app.server.send_trying = 1;
			break;
		case OPT_RINGING:
			app.server.send_ringing = 1;
			break;
		default:
			PJ_LOG(1,(THIS_FILE, "Invalid argument. Use --help to see help"));
			return -1;
		}
	}

	if (pj_optind != argc) {
		if (verify_sip_url(argv[pj_optind]) != PJ_SUCCESS) {
		    PJ_LOG(1,(THIS_FILE, "Invalid SIP URI %s", argv[pj_optind]));
		    return -1;
		}
		app.client.dst_uri = pj_str(argv[pj_optind]);
		pj_optind++;
	}

	if (pj_optind != argc) {
		PJ_LOG(1,(THIS_FILE, "Error: unknown options %s", argv[pj_optind]));
		return -1;
	}

	return 0;
}


/* Send one stateless request */
static pj_status_t submit_stateless_job(void) {
    pjsip_tx_data *tdata;
    pj_status_t status;

	PJ_LOG(1, (THIS_FILE, "submit_stateless job"));
    status = pjsip_endpt_create_request(app.sip_endpt, &app.client.method, 
					&app.client.dst_uri, &app.local_uri,
					&app.client.dst_uri, &app.local_contact,
					NULL, -1, NULL, &tdata);
    if (status != PJ_SUCCESS) {
	app_perror(THIS_FILE, "Error creating request", status);
	report_completion(701, NULL, NULL);
	return status;
    }

	if (app.disable_connection_reuse)
		tdata->tp_sel.disable_connection_reuse = PJ_TRUE;

    status = pjsip_endpt_send_request_stateless(app.sip_endpt, tdata, NULL, NULL);
    if (status != PJ_SUCCESS) {
	pjsip_tx_data_dec_ref(tdata);
	app_perror(THIS_FILE, "Error sending stateless request", status);
	report_completion(701, NULL, NULL);
	return status;
    }

    return PJ_SUCCESS;
}


/* This callback is called when client transaction state has changed */
static void tsx_completion_cb(void *token, pjsip_event *event) {
	pjsip_transaction *tsx;
	PJ_UNUSED_ARG(token);

	if (event->type != PJSIP_EVENT_TSX_STATE)
		return;

	tsx = event->body.tsx_state.tsx;

	if (tsx->mod_data[mod_test.id] != NULL) {
		/* This transaction has been calculated before */
		return;
	}

	if (tsx->state==PJSIP_TSX_STATE_TERMINATED) {
		report_completion(tsx->status_code, &tsx->method.name, NULL);
		tsx->mod_data[mod_test.id] = (void*)(pj_ssize_t)1;
	} else if (tsx->method.id == PJSIP_INVITE_METHOD &&
		tsx->state == PJSIP_TSX_STATE_CONFIRMED) {
		report_completion(tsx->status_code, &tsx->method.name, NULL);
		tsx->mod_data[mod_test.id] = (void*)(pj_ssize_t)1;
	} else if (tsx->state == PJSIP_TSX_STATE_COMPLETED) {
		report_completion(tsx->status_code, &tsx->method.name, NULL);
		tsx->mod_data[mod_test.id] = (void*)(pj_ssize_t)1;
		TERMINATE_TSX(tsx, tsx->status_code);
	}
}


/* Send one stateful request */
static pj_status_t submit_job(void) {
	pjsip_tx_data *tdata;
	pj_status_t status;
	status = pjsip_endpt_create_request(app.sip_endpt, &app.client.method,
					&app.client.dst_uri, &app.local_uri,
					&app.client.dst_uri, &app.local_contact,
					NULL, -1, NULL, &tdata);
	if (status != PJ_SUCCESS) {
		app_perror(THIS_FILE, "Error creating request", status);
		report_completion(701, NULL, NULL);
		return status;
	}
	if (app.disable_connection_reuse)
		tdata->tp_sel.disable_connection_reuse = PJ_TRUE;
	status = pjsip_endpt_send_request(app.sip_endpt, tdata, -1, NULL, &tsx_completion_cb);
	if (status != PJ_SUCCESS) {
		app_perror(THIS_FILE, "Error sending stateful request", status);
		//should have been reported by tsx_completion_cb().
		//report_completion(701);
		//No longer necessary (r777)
		//pjsip_tx_data_dec_ref(tdata);
	}
	return status;
}


/* Client worker thread */
static int client_thread(void *arg) {
	pj_time_val end_time, last_report, now;
	unsigned thread_index = (unsigned)(long)(pj_ssize_t)arg;
	unsigned cycle = 0, last_cycle = 0;

	pj_thread_sleep(100);
	PJ_LOG(1, (THIS_FILE, "client_thread[%ld]", thread_index));

	pj_gettimeofday(&end_time);
	end_time.sec += app.client.timeout;

	pj_gettimeofday(&last_report);

	if (app.client.first_request.sec == 0) {
		pj_gettimeofday(&app.client.first_request);
	}

	/* Submit all jobs */
	while (app.client.job_submitted < app.client.job_count && !app.thread_quit) {
		pj_time_val timeout = { 0, 1 };
		unsigned i;
		int outstanding;
		pj_status_t status;

		/* Calculate current outstanding job */
		outstanding = app.client.job_submitted - app.client.job_finished;

		/* Update stats on max outstanding jobs */
		if (outstanding > (int)app.client.stat_max_window)
			app.client.stat_max_window = outstanding;

		/* Wait if there are more pending jobs than allowed in the
		 * window. But spawn a new job anyway if no events are happening
		 * after we wait for some time.
		 */
		for (i=0; outstanding > (int)app.client.job_window && i<1000; ++i) {
			PJ_LOG(4, (THIS_FILE, "wait_ms[500ms]"));
			pj_time_val wait = { 0, 500 };
			unsigned count = 0;
			pjsip_endpt_handle_events2(app.sip_endpt, &wait, &count);
			outstanding = app.client.job_submitted - app.client.job_finished;
			if (count == 0)
				break;
			++cycle;
		}

		pj_time_val start;
		pj_gettimeofday(&start);
		if (thread_index == 0) status_check_period(PJ_FALSE);

		// cps_period.calls_count_period
		// INIT
		if (app.cps_period.call_count == 0) {
			pj_lock_acquire(app.cps_lock);
			pj_gettimeofday(&app.cps_period.start);
			app.cps_period.cpms = app.client.cps / 1000;
			if (app.cps_period.cpms < 1)
				app.cps_period.cpms = 1;
			pj_lock_release(app.cps_lock);
		}

		while (app.cps_period.call_count_ms >= app.cps_period.cpms) {
			pj_time_val wait = { 0, 1 };
			pj_time_val now, after;
			unsigned count = 0;
			pj_gettimeofday(&now);

			pj_lock_acquire(app.cps_lock);
			if (now.msec != app.cps_period.last_sleep.msec) {
				app.cps_period.last_sleep.msec = now.msec;
				app.cps_period.call_count_ms = 0;
			}
			pj_lock_release(app.cps_lock);

			pj_gettimeofday(&now);
			pjsip_endpt_handle_events2(app.sip_endpt, &wait, &count);
			pj_gettimeofday(&after);
			PJ_TIME_VAL_SUB(after, now);
			if (after.msec > 5) PJ_LOG(1, (THIS_FILE, "event count[%d] delay[%d.%d]", count, (int)after.sec, (int)after.msec));

			// CHECK CPS PERIOD
			pj_gettimeofday(&now);
			pj_lock_acquire(app.cps_lock);
			PJ_TIME_VAL_SUB(now, app.cps_period.start);
			if (now.sec >= 1) {
				pj_gettimeofday(&app.cps_period.start);
				PJ_LOG(1, (THIS_FILE, "cps_period.calls_count_period[%d] duration[%d.%d]", app.cps_period.call_count, (int)now.sec, (int)now.msec));
				app.cps_period.call_count = 0;
			} else {
				// CHECK CPS THROTTLE
				int cps_remaining = app.client.cps - app.cps_period.call_count;
				int cps_period_remaining_ms = 1000 - now.msec;	
				app.cps_period.cpms = cps_remaining/(float)cps_period_remaining_ms;
				if (app.cps_period.cpms < 0)
					app.cps_period.cpms = 0;
				PJ_LOG(4, (THIS_FILE, "cps_period.calls_count_period[%d/%d] elapsed[%dms] new_cpms[%.2f] [%d/%d]",
								app.cps_period.call_count, app.client.cps,
                                                                (int)now.msec,
                                                                app.cps_period.cpms, cps_remaining, cps_period_remaining_ms));
			}
			pj_lock_release(app.cps_lock);
		}
		PJ_LOG(4, (THIS_FILE, "cps_period.calls_count_period[%d][%d.%d] cpms[%.2f]", app.cps_period.call_count, (int)app.cps_period.start.sec, (int)app.cps_period.start.msec, app.cps_period.cpms));

		/* Submit one job */
		if (app.client.method.id == PJSIP_INVITE_METHOD) {
			status = make_call(&app.client.dst_uri);
		} else if (app.client.stateless) {
			status = submit_stateless_job();
		} else {
			status = submit_job();
		}
		++app.cps_period.call_count_ms;
		++app.cps_period.call_count;
		++app.client.job_submitted;
		++cycle;

		/* Handle event */
		pjsip_endpt_handle_events2(app.sip_endpt, &timeout, NULL);

		/* Check for time out, also print report */
		if (cycle - last_cycle >= 5000) {
			pj_gettimeofday(&now);
			if (PJ_TIME_VAL_GTE(now, end_time)) {
				PJ_LOG(1, (THIS_FILE, "scenario execution took too long, max was[%dseconds] you can increase the param: --timeout=SEC, -t", app.client.timeout));
				break;
			}
			last_cycle = cycle;

			if (thread_index == 0 && now.sec-last_report.sec >= 2) {
				printf("\r%d jobs started, %d completed...   ",
				app.client.job_submitted, app.client.job_finished);
				fflush(stdout);
				last_report = now;
			}
		}
	}

	if (app.client.requests_sent.sec == 0) {
		pj_gettimeofday(&app.client.requests_sent);
	}
	if (thread_index == 0) {
		printf("\r%d jobs started, %d completed%s\n",
		       app.client.job_submitted, app.client.job_finished,
		       (app.client.job_submitted!=app.client.job_finished ? 
			", waiting..." : ".") );
		fflush(stdout);
	}

	/* Wait until all jobs completes, or timed out */
	pj_gettimeofday(&now);
	while (PJ_TIME_VAL_LT(now, end_time) && 
		   app.client.job_finished < app.client.job_count && 
		   !app.thread_quit) 
	{
		pj_time_val timeout = { 0, 10 }; // TIMEOUT 1
		unsigned i;

		for (i=0; i<1000; ++i) {
		    unsigned count;
		    count = 0;
		    pjsip_endpt_handle_events2(app.sip_endpt, &timeout, &count);
		    if (count == 0)
			break;
		}
	
		pj_gettimeofday(&now);
	    }
	
	    /* Wait couple of seconds to let jobs completes (e.g. ACKs to be sent)  */
	    pj_gettimeofday(&now);
	    end_time = now;
	    end_time.sec += 2;
	    while (PJ_TIME_VAL_LT(now, end_time)) 
	    {
		pj_time_val timeout = { 0, 1 };
		unsigned i;
	
		for (i=0; i<1000; ++i) {
		    unsigned count;
		    count = 0;
		    pjsip_endpt_handle_events2(app.sip_endpt, &timeout, &count);
		    if (count == 0)
			break;
		}
	
		pj_gettimeofday(&now);
	    }
	
	    return 0;
}


static const char *good_number(char *buf, pj_int32_t val)
{
    if (val < 1000) {
	pj_ansi_sprintf(buf, "%d", val);
    } else if (val < 1000000) {
	pj_ansi_sprintf(buf, "%d.%dK", 
			val / 1000,
			(val % 1000) / 100);
    } else {
	pj_ansi_sprintf(buf, "%d.%02dM", 
			val / 1000000,
			(val % 1000000) / 10000);
    }

    return buf;
}


static int server_thread(void *arg)
{
    pj_time_val timeout = { 0, 1 };
    unsigned thread_index = (unsigned)(long)(pj_ssize_t)arg;
    pj_time_val last_report, next_report;

    pj_gettimeofday(&last_report);
    next_report = last_report;
    next_report.sec++;

    while (!app.thread_quit) {
	pj_time_val now;
	unsigned i;

	for (i=0; i<100; ++i) {
	    unsigned count = 0;
	    pjsip_endpt_handle_events2(app.sip_endpt, &timeout, &count);
	    if (count == 0)
		break;
	}

	if (thread_index == 0) {
	    pj_gettimeofday(&now);

	    if (PJ_TIME_VAL_GTE(now, next_report)) {
		pj_time_val tmp;
		unsigned msec;
		unsigned stateless, stateful, call;
		char str_stateless[32], str_stateful[32], str_call[32];

		tmp = now;
		PJ_TIME_VAL_SUB(tmp, last_report);
		msec = PJ_TIME_VAL_MSEC(tmp);

		last_report = now;
		next_report = last_report;
		if (app.server.console_mode) {
			next_report.sec++;
		} else {
			next_report.sec+=5;
		}
		stateless = app.server.cur_state.stateless_cnt - app.server.prev_state.stateless_cnt;
		stateful = app.server.cur_state.stateful_cnt - app.server.prev_state.stateful_cnt;
		call = app.server.cur_state.call_cnt - app.server.prev_state.call_cnt;

		good_number(str_stateless, app.server.cur_state.stateless_cnt);
		good_number(str_stateful, app.server.cur_state.stateful_cnt);
		good_number(str_call, app.server.cur_state.call_cnt);

		printf("Total(rate): stateless:%s (%d/s), statefull:%s (%d/s), call:%s (%d/s)       %c",
		       str_stateless, stateless*1000/msec,
		       str_stateful, stateful*1000/msec,
		       str_call, call*1000/msec,
		       ((app.server.console_mode) ? '\r' : '\n')
		);
		fflush(stdout);

		app.server.prev_state = app.server.cur_state;
	    }
	}
    }

    return 0;
}

static void write_report(const char *msg, pj_bool_t log) {
	if (log) {
		PJ_LOG(1, (THIS_FILE, "%s", msg));
		return;
	}
	puts(msg);
#if (defined(PJ_WIN32) && PJ_WIN32!=0) || (defined(PJ_WIN64) && PJ_WIN64!=0)
	OutputDebugString(msg);
	OutputDebugString("\n");
#endif
}

// Handler for SIGINT, caused by
// Ctrl-C at keyboard
void handle_sigint(int sig) {
	printf("Caught signal %d\n", sig);
	fflush(stdout);
	destroy_app();
}

void print_detailed_response_code_received(pj_bool_t log) {
	static char report[1024];
	int i;

	/* Print detailed response code received */
	pj_ansi_sprintf(report, ">> Detailed connection responses received:");
	write_report(report, log);
	for (i=0; i<PJ_ARRAY_SIZE(app.client.connection_response_codes); ++i) {
		const pj_str_t *reason;
		if (app.client.connection_response_codes[i] == 0) continue;
		reason = pjsip_get_status_text(i);
		pj_ansi_snprintf( report, sizeof(report),
			      " - %d connection responses:  %7d     (%.*s)",
			      i, app.client.connection_response_codes[i],
			      (int)reason->slen, reason->ptr);

		write_report(report, log);
	}
	pj_ansi_sprintf(report, ">> Detailed disconnection responses received:");
	write_report(report, log);
	for (i=0; i<PJ_ARRAY_SIZE(app.client.response_codes); ++i) {
		const pj_str_t *reason;
		if (app.client.response_codes[i] == 0) continue;
		reason = pjsip_get_status_text(i);
		pj_ansi_snprintf( report, sizeof(report),
			      " - %d disconnection responses:  %7d     (%.*s)",
			      i, app.client.response_codes[i],
			      (int)reason->slen, reason->ptr);
		write_report(report, log);
	}
}

int main(int argc, char *argv[]) {
	static char report[1024];

	srand(time(NULL));
	if (create_app() != 0) return 1;
	if (init_options(argc, argv) != 0) return 1;
	pj_log_set_level(app.log_level);
	printf("log level set to :%d\n", app.log_level);
	if (load_json_config(app.cfg_fn.ptr) != 0) return 1;
	if (init_sip() != 0) return 1;
	if (init_media() != 0) return 1;

	if (app.log_level > 4) {
		pjsip_endpt_register_module(app.sip_endpt, &msg_logger);
	}

	/* Misc infos */
	if (app.client.dst_uri.slen != 0) {
		if (app.client.method.id == PJSIP_INVITE_METHOD) {
			if (app.client.stateless) {
				PJ_LOG(3,(THIS_FILE, "Info: --stateless option makes no sense for INVITE, ignored."));
			}
		}
	}

	if (app.client.dst_uri.slen || app.client_mode) {
		/* Client mode */
		pj_status_t status;
		char test_type[64];
		unsigned msec_req, msec_res;
		unsigned i;

		status = pj_lock_create_simple_mutex(app.pool, "stats_lock", &app.stats_lock);
		if (status != PJ_SUCCESS) {
			app_perror(THIS_FILE, "unable to create lock", status);
		}
		status = pj_lock_create_simple_mutex(app.pool, "cps_lock", &app.cps_lock);
		if (status != PJ_SUCCESS) {
			app_perror(THIS_FILE, "unable to create lock", status);
		}
		pj_gettimeofday(&app.latency_metrics_period_start);
		pj_gettimeofday(&app.status_metrics_period_start);
		log_stats_output = fopen(app.latency_fn.ptr, "w+");
		fflush(log_stats_output);
		fprintf(log_stats_output,"TIMESTAMP,METHOD,100-CNT,100-AVG,100-STD,100-MAX,180-CNT,180-AVG,180-STD,180-MAX,200-CNT,200-AVG,200-STD,200-MAX\n");

		/* Get the job name */
		if (app.client.method.id == PJSIP_INVITE_METHOD) {
		    pj_ansi_strcpy(test_type, "INVITE calls");
		} else if (app.client.stateless) {
		    pj_ansi_sprintf(test_type, "stateless %.*s requests",
				    (int)app.client.method.name.slen,
				    app.client.method.name.ptr);
		} else {
		    pj_ansi_sprintf(test_type, "stateful %.*s requests",
				    (int)app.client.method.name.slen,
				    app.client.method.name.ptr);
		}

		// Sending 1 INVITE calls to 'sip:0@147.75.69.1:5070' with 1000 maximum outstanding jobs, please wait..
		printf("Sending %d %s to '%.*s' with %d maximum outstanding jobs, please wait..\n", 
			  app.client.job_count, test_type,
			  (int)app.client.dst_uri.slen, app.client.dst_uri.ptr,
			  app.client.job_window);

		for (i=0; i<app.thread_count; ++i) {
			status = pj_thread_create(app.pool, NULL, &client_thread, (void*)(pj_ssize_t)i, 0, 0, &app.thread[i]);
			if (status != PJ_SUCCESS) {
				app_perror(THIS_FILE, "Unable to create thread", status);
				return 1;
			}
		}

		for (i=0; i<app.thread_count; ++i) {
			pj_thread_join(app.thread[i]);
			app.thread[i] = NULL;
		}

		metric_check_period(PJ_TRUE);

		if (app.client.last_completion.sec) {
			pj_time_val duration;
			duration = app.client.last_completion;
			PJ_TIME_VAL_SUB(duration, app.client.first_request);
			msec_res = PJ_TIME_VAL_MSEC(duration);
		} else {
			msec_res = app.client.timeout * 1000;
		}

		if (msec_res == 0) msec_res = 1;
		if (app.client.requests_sent.sec) {
			pj_time_val duration;
			duration = app.client.requests_sent;
			PJ_TIME_VAL_SUB(duration, app.client.first_request);
			msec_req = PJ_TIME_VAL_MSEC(duration);
		} else {
			msec_req = app.client.timeout * 1000;
		}

		if (msec_req == 0) msec_req = 1;
		if (app.client.job_submitted < app.client.job_count) puts("\ntimed-out!\n");
		else puts("\ndone.\n");

		pj_ansi_snprintf(
		    report, sizeof(report),
		    "Total %d %s sent in %d ms at rate of %d/sec\n"
		    "Total %d connection responses received in %d ms at rate of %d/sec:",
		    app.client.job_submitted, test_type, msec_req, 
		    app.client.job_submitted * 1000 / msec_req,
		    app.client.connection_total_responses, msec_res,
		    app.client.connection_total_responses*1000/msec_res);
		write_report(report, PJ_FALSE);

		print_detailed_response_code_received(PJ_FALSE);

		/* Total responses and rate */
		pj_ansi_snprintf( report, sizeof(report),
		    "                    ------\n"
		    " TOTAL responses:  %7d (rate=%d/sec)\n",
		    app.client.total_responses,
		    app.client.total_responses*1000/msec_res);

		write_report(report, PJ_FALSE);
		pj_ansi_sprintf(report, "Maximum outstanding job: %d", app.client.stat_max_window);
		write_report(report, PJ_FALSE);

	} else {
		/* Server mode */
		char s[10], *unused;
		pj_status_t status;
		unsigned i;
		printf("voip_perf %s started in server-mode\n", VERSION);
		printf("Receiving requests on the following URIs:\n"
		       "  sip:0@%.*s:%d%s    for stateless handling\n"
		       "  sip:1@%.*s:%d%s    for stateful handling\n"
		       "  sip:2@%.*s:%d%s    for call handling\n",
		       (int)app.local_addr.slen,
		       app.local_addr.ptr,
		       app.local_port,
		       (app.use_tcp ? ";transport=tcp" : ""),
		       (int)app.local_addr.slen,
		       app.local_addr.ptr,
		       app.local_port,
		       (app.use_tcp ? ";transport=tcp" : ""),
		       (int)app.local_addr.slen,
		       app.local_addr.ptr,
		       app.local_port,
		       (app.use_tcp ? ";transport=tcp" : ""));
		printf("INVITE with non-matching user part will be handled call-statefully\n");

		for (i=0; i<app.thread_count; ++i) {
		    status = pj_thread_create(app.pool, NULL, &server_thread, 
					      (void*)(pj_ssize_t)i, 0, 0, 
					      &app.thread[i]);
		    if (status != PJ_SUCCESS) {
			app_perror(THIS_FILE, "Unable to create thread", status);
			return 1;
		    }
		}

		if (app.server.console_mode) {
			puts("\nPress <ENTER> to quit\n");
			fflush(stdout);
			unused = fgets(s, sizeof(s), stdin);
			PJ_UNUSED_ARG(unused);
			destroy_app();
		} else {
			signal(SIGINT, handle_sigint);
			for (i=0; i<app.thread_count; ++i)
				pj_thread_join(app.thread[i]);
		}
	}
	return 0;
}



